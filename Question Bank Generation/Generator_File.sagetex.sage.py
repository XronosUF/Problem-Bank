## -*- encoding: utf-8 -*-

# This file was *autogenerated* from the file Generator_File.sagetex.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_155 = Integer(155); _sage_const_11 = Integer(11); _sage_const_16 = Integer(16)## This file (Generator_File.sagetex.sage) was *autogenerated* from Generator_File.tex with sagetex.sty version 2015/08/26 v3.0-92d9f7a.
import sagetex
_st_ = sagetex.SageTeXProcessor('Generator_File', version='2015/08/26 v3.0-92d9f7a', version_check=True)
_st_.current_tex_line = _sage_const_5 
_st_.blockbegin()
try:
 #####Define default Sage variables.
 #Default function variables
 var('x,y,z,X,Y,Z')
 #Default function names
 var('f,g,h,dx,dy,dz,dh,df')
 #Default Wild cards
 w0 = SR.wild(_sage_const_0 )
 
 
 #Define a function to get a random computable angle between 0 and 2pi.
 #Syntax: RandAng(AngMin, AngMax) Where Angmin is minimum desired angle, Angmax is maximum desired angle. These are not strict inequalities, be wary.
 
 def RandAng(s,t):
    angle=[_sage_const_0 , pi/_sage_const_6 ,pi/_sage_const_4 ,pi/_sage_const_3 ,pi/_sage_const_2 , _sage_const_2 *pi/_sage_const_3 ,_sage_const_3 *pi/_sage_const_4 ,_sage_const_5 *pi/_sage_const_6 ,pi, _sage_const_7 *pi/_sage_const_6 ,_sage_const_5 *pi/_sage_const_4 ,_sage_const_4 *pi/_sage_const_3 ,_sage_const_3 *pi/_sage_const_2 , _sage_const_5 *pi/_sage_const_3 ,_sage_const_7 *pi/_sage_const_4 ,_sage_const_11 *pi/_sage_const_6 ,_sage_const_2 *pi ]
    theta=Integer(randint(_sage_const_0 ,_sage_const_16 ))
    Ang=angle[theta]
    while Ang<=s or Ang>=t:
       theta=Integer(randint(_sage_const_0 ,_sage_const_16 ))
       Ang=angle[theta]
    return simplify(Ang)
 
 
 #####Define a sage function to take in a number and return the signed number, so -3 returns "-3" and 3 returns "+3" to interface with Latex correctly. Note this only works with numbers, and if 0 is entered, it returns blank space (To avoid the +0 or -0 result).
 
 var('TempSignVar11')
 
 def ISP(b):
    if b > _sage_const_0 :
       TempSignVar11 ="+"
    elif b < _sage_const_0 :
       TempSignVar11 ="-"
       b = -b
    else:
       b =""
       TempSignVar11 =""
    b = str(b)
    return TempSignVar11 + b
 ###################################
 
 # Define a function to substitute a number for a variable in a function without actually evaluating that function.
 
 def NoEval(f, c):
     cstr = str(c)
 #    flatex = latex(f)
     fstring = latex(f)
     fstrlist = list(fstring)
     length = len(fstrlist)
     fstrlist2 = range(length)
     for i in range(_sage_const_0 , length):
         if fstrlist[i] == "x":
             fstrlist2[i] = "("+cstr+")"
         else:
             fstrlist2[i] = fstrlist[i]
     f2 = join(fstrlist2,"")
     return LatexExpr(f2)
 
 ###################################
 # Define a function that will convert out hyperbolic expressions and simplify them.
 
 def HyperSimp(f):
     ftemp = f
     ftemp1 = ftemp.substitute(sinh(w0) == (exp(w0) - exp(-w0))/_sage_const_2 )
     ftemp2 = ftemp1.substitute(cosh(w0) == (exp(w0) + exp(-w0))/_sage_const_2 )
     ftemp6 = ftemp2.substitute(tanh(w0) == (exp(w0) - exp(-w0))/(exp(w0) + exp(-w0)))
 #Not working yet    ftemp4 = ftemp3.substitute(sech(w0) == 2/(exp(w0) + exp(-w0)))
 #Not working yet    ftemp5 = ftemp4.substitute(csch(w0) == 2/(exp(w0) - exp(-w0)))
 #Not working yet    ftemp6 = ftemp5.substitute(coth(w0) == (exp(w0) + exp(-w0))/(exp(w0) - exp(-w0)))
     ftemp7 = ftemp6.substitute(arcsinh(w0) == ln( w0 + sqrt((w0)**_sage_const_2  + _sage_const_1 )))
     ftemp8 = ftemp7.substitute(arccosh(w0) == ln( w0 + sqrt((w0)**_sage_const_2  - _sage_const_1 )))
     ftemp9 = ftemp8.substitute(arctanh(w0) == _sage_const_1 /_sage_const_2  * ln( (_sage_const_1  + w0)/ (_sage_const_1  - w0) ))
     ftemp10 = ftemp9.substitute(arccsch(w0) == ln( (_sage_const_1  + sqrt((w0)**_sage_const_2  + _sage_const_1 ))/w0))
     ftemp11 = ftemp10.substitute(arcsech(w0) == ln( (_sage_const_1  + sqrt(_sage_const_1  - (w0)**_sage_const_2 ))/w0))
     ftemp12 = ftemp11.substitute(arccoth(w0) == _sage_const_1 /_sage_const_2  * ln( (_sage_const_1  + w0)/ (w0 - _sage_const_1 ) ))
     ffinal = ftemp12
     return simplify(ffinal)
 
 ###################################
 
 # Define a quick version of Integer(randint(-a,b))
 
 def RandInt(a,b):
     return Integer(randint(a,b))
 
 
 
 ###################################
 #Define a function to create an integer from b to c that is not some set of numbers (default is not 0).
 ##
 ## Syntax: To generate a non zero integer between -3 and 17, use NonZeroInt(-3,17).
 ## To generate a number between -3 and 17, that is not 0, 5, or ROOT1 (Where ROOT1 is a variable calculated earlier in the code) use NonZeroInt(-3,17, [0, 5, ROOT1]).
 ##
 
 
 var('TempVar21')
 
 def NonZeroInt(b,c, D = [_sage_const_0 ]):
    TempVar21 = Integer(randint(b,c))
    while TempVar21 in D:
       TempVar21 = Integer(randint(b,c))
    return TempVar21
 ###################################
 
 
 ### Define a Random Nonzero vector in range b to c inclusive
 ## Syntax: RandomVector(A,B,[LIST], C):
 ##
 ## The function will generate a list of numbers from A to B, in randomized order.
 ## If you wish to remove any values from the list (such as 0, or the sage number calculated earlier) include it in the LIST area. Note the [], they are necessary. This argument is optional.
 ## If you wish to duplicate the string (before it is randomized) a certain number of times, put that number in for C. This argument is optional.
 ##
 ## So, for example, if you want to just generate a list of numbers in random order from -5 to 17, use: RandomVector(-5,17).
 ## If you want to generate a list of random numbers that include -4 to 12, but not 0, -2, or ROOT1 (a variable calculated earlier in the code), and have each number occuring 3 times use: RandomVector(-4,12,[0,-2,ROOT1], 3).
 
 var('TVecFun11')
 var('TVecFun12')
 var('TVecFun13')
 var('TVecFun14')
 var('TVecFun15')
 import random
 
 def RandomVector(b,c,TVecFun12=[],TVecFun13 = _sage_const_1 ):
    TVecFun11 = range(b, c+_sage_const_1 )
    TVecFun15 = [p for p in TVecFun11 if p not in TVecFun12]
    TVecFun14 = TVecFun15
    for j in range(_sage_const_1 , TVecFun13):
       TVecFun14 = TVecFun14 + TVecFun15
    random.shuffle(TVecFun14)
    return TVecFun14
 
 ## Diagonal of the matrix.
 def diag(A,dim,B):
    for i in range(dim):
       B[i,i] = A[i,i]
    return B
 
 
 ## Generate a random QQ matrix
 def gen_matrix(dim1, dim2, LBnum,UBnum,LBden,UBden):
    Temp = matrix(QQ, dim1, dim2, _sage_const_0 )
    for i in range(dim1):
       for j in range(dim2):
          num = RandInt(LBnum, UBnum)
          den = RandInt(LBden, UBden)
          Temp[i,j] = num/den
    return Temp
 
 
 ###################################
 
except:
 _st_.goboom(_sage_const_155 )
_st_.blockend()
_st_.endofdoc()

